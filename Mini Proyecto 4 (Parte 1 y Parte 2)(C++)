#include "raylib.h"
#include <vector>
#include <string>
#include <map>
#include <random>
#include <chrono>
#include <sstream>
#include <utility>
#include <algorithm>

using namespace std;

const int N = 20;            // tamaño del mapa (N x N)
const int CELL = 28;         // tamaño de cada celda en píxeles
const int MARGIN = 8;        // margen
const int HUD_HEIGHT = 80;   // espacio inferior para HUD
const int INV_WIDTH = 320;   // ancho del panel de inventario a la derecha

const int MAP_W = N * CELL + MARGIN * 2;
const int SCREEN_W = MAP_W + INV_WIDTH + MARGIN; // mapa + inventario + margen
const int SCREEN_H = N * CELL + MARGIN * 2 + HUD_HEIGHT;

const int INIT_LIVES = 3;
const int INIT_ENERGY = 4;
const int MAX_ENERGY = 10;
const float TOTAL_TIME = 180.0f; // 3 minutos

struct Pos { int r, c; };
struct TreasureInfo { string name; int value; };

int main() {
    InitWindow(SCREEN_W, SCREEN_H, "Laberinto - Raylib");
    SetTargetFPS(60);

    // RNG
    std::mt19937 rng((unsigned)chrono::high_resolution_clock::now().time_since_epoch().count());
    auto rnd01 = [&](double p)->bool { uniform_real_distribution<double> d(0.0,1.0); return d(rng) < p; };
    auto rndInt = [&](int a,int b)->int { uniform_int_distribution<int> d(a,b); return d(rng); };

    // grid y visibilidad
    vector<string> grid(N, string(N, ' '));
    vector<vector<bool>> visible(N, vector<bool>(N, false));
    double wall_density = 0.20;
    for (int i=0;i<N;i++) for (int j=0;j<N;j++) if (rnd01(wall_density)) grid[i][j] = '#';
    for (int i=0;i<N;i++){ grid[i][0]='#'; grid[i][N-1]='#'; grid[0][i]='#'; grid[N-1][i]='#'; }

    // player start
    Pos player{0,0};
    bool found=false;
    for (int attempts=0; attempts<10000 && !found; ++attempts) {
        int r=rndInt(0,N-1), c=rndInt(0,N-1);
        if (grid[r][c]==' ') { player.r=r; player.c=c; visible[r][c]=true; found=true; }
    }
    if (!found) for (int i=0;i<N && !found;i++) for (int j=0;j<N && !found;j++) if (grid[i][j]==' ') { player.r=i; player.c=j; visible[i][j]=true; found=true; }

    // crear 12 tesoros (nombres + valores únicos)
    vector<TreasureInfo> treasuresAll;
    vector<string> names = {
        "Cofre de Coral","Corona Antigua","Anillo Solar","Sello Lunar",
        "Joyel de Rubi","Esfera de Hueso","Mapa Dorado","Medallon Verde",
        "Pergamino Antiguo","Gema Azul","Cetro Pequeño","Relicario"
    };
    vector<int> values;
    while ((int)values.size() < 12) {
        int v = rndInt(10,120);
        if (find(values.begin(), values.end(), v) == values.end()) values.push_back(v);
    }
    for (int i=0;i<12;i++) treasuresAll.push_back({names[i], values[i]});

    // map pos -> index tesoro
    map<pair<int,int>,int> mapPosToTreasureIndex;
    int placed_t = 0;
    for (int t=0; t<12 && placed_t < N*N; ++t) {
        bool placed=false;
        for (int a=0;a<2000 && !placed;++a) {
            int r=rndInt(0,N-1), c=rndInt(0,N-1);
            if (grid[r][c]==' ' && !(r==player.r && c==player.c)) {
                grid[r][c] = 'T';
                mapPosToTreasureIndex[{r,c}] = t;
                placed=true; placed_t++;
            }
        }
        if (!placed) break;
    }

    // trampas
    int max_traps = 6;
    for (int t=0;t<max_traps;++t) {
        bool placed=false;
        for (int a=0;a<2000 && !placed;++a) {
            int r=rndInt(0,N-1), c=rndInt(0,N-1);
            if (grid[r][c]==' ' && !(r==player.r && c==player.c)) { grid[r][c] = 'X'; placed=true; }
        }
        if (!placed) break;
    }

    // estado
    int lives = INIT_LIVES;
    int energy = INIT_ENERGY;
    int score = 0;
    int consec_no_hit = 0;
    vector<TreasureInfo> inventory; inventory.reserve(12);

    // temporizador y mensajes
    float timeLeft = TOTAL_TIME;
    double prevTime = GetTime();
    string lastMessage = "";
    float messageTimer = 0.0f;

    int fontSize = 18;

    // Inventario (panel derecho)
    const int invPanelX = MAP_W + MARGIN/2;     // comienza justo después del mapa
    const int invPanelY = MARGIN;
    const int invPanelW = INV_WIDTH - MARGIN;   // ancho usable
    const int invPanelH = N * CELL;             // altura para lista (misma que mapa)
    const int itemLineHeight = 18;

    int invScroll = 0;

    // loop
    while (!WindowShouldClose()) {
        // delta time
        double now = GetTime();
        float dt = (float)(now - prevTime);
        prevTime = now;
        if (lives > 0) timeLeft = max(0.0f, timeLeft - dt);
        if (messageTimer > 0.0f) { messageTimer = max(0.0f, messageTimer - dt); if (messageTimer == 0.0f) lastMessage.clear(); }

        // input movimiento
        int dr = 0, dc = 0;
        if (IsKeyPressed(KEY_UP) || IsKeyPressed(KEY_W)) dr = -1;
        else if (IsKeyPressed(KEY_DOWN) || IsKeyPressed(KEY_S)) dr = 1;
        else if (IsKeyPressed(KEY_LEFT) || IsKeyPressed(KEY_A)) dc = -1;
        else if (IsKeyPressed(KEY_RIGHT) || IsKeyPressed(KEY_D)) dc = 1;
        else if (IsKeyPressed(KEY_Q)) break;

        Vector2 mouse = GetMousePosition();
        float wheel = GetMouseWheelMove();
        Rectangle invAreaRect = { (float)invPanelX, (float)invPanelY + 40.0f, (float)invPanelW - 16.0f, (float)invPanelH - 60.0f };
        int itemsPerPage = std::max<int>(1, (int)(invAreaRect.height) / itemLineHeight);
        int maxScroll = std::max<int>(0, (int)inventory.size() - itemsPerPage);


        if (CheckCollisionPointRec(mouse, invAreaRect) && wheel != 0.0f) {
            invScroll -= (int)wheel; // rueda arriba -> invScroll--
        }
        if (IsKeyPressed(KEY_PAGE_UP)) invScroll -= itemsPerPage;
        if (IsKeyPressed(KEY_PAGE_DOWN)) invScroll += itemsPerPage;
        if (IsKeyPressed(KEY_HOME)) invScroll = 0;
        if (IsKeyPressed(KEY_END)) invScroll = maxScroll;
        if (invScroll < 0) invScroll = 0;
        if (invScroll > maxScroll) invScroll = maxScroll;

        // movimiento del jugador (solo si hay vida y tiempo)
        if ((dr != 0 || dc != 0) && lives > 0 && timeLeft > 0.0f) {
            int nr = player.r + dr;
            int nc = player.c + dc;
            if (nr < 0 || nr >= N || nc < 0 || nc >= N) {
                if (energy > 0) { energy--; lastMessage = "Chocaste contra el borde: -1 energia"; messageTimer = 2.0f; }
                else { lives--; energy = INIT_ENERGY; lastMessage = "Sin energia: -1 vida y energia restaurada"; messageTimer = 2.0f; }
                consec_no_hit = 0;
            } else {
                char cell = grid[nr][nc];
                if (cell == '#') {
                    visible[nr][nc] = true;
                    if (energy > 0) { energy--; lastMessage = "Chocaste contra una pared: -1 energia"; messageTimer = 2.0f; }
                    else { lives--; energy = INIT_ENERGY; lastMessage = "Sin energia al chocar: -1 vida y energia restaurada"; messageTimer = 2.0f; }
                    consec_no_hit = 0;
                } else {
                    player.r = nr; player.c = nc; visible[nr][nc] = true; consec_no_hit++;
                    if (consec_no_hit >= 3) { if (energy < MAX_ENERGY) { energy++; lastMessage = "+1 energia por 3 pasos seguidos"; messageTimer = 1.5f; } consec_no_hit = 0; }
                    if (cell == 'X') { lives--; grid[nr][nc] = ' '; score = max(0, score - 10); lastMessage = "Caiste en una trampa: -1 vida -10 pts"; messageTimer = 2.0f; }
                    else if (cell == 'T') {
                        auto it = mapPosToTreasureIndex.find({nr,nc});
                        if (it != mapPosToTreasureIndex.end()) {
                            int idx = it->second;
                            if (idx >= 0 && idx < (int)treasuresAll.size()) {
                                inventory.push_back(treasuresAll[idx]);
                                score += treasuresAll[idx].value;
                                stringstream ss; ss << "Recolectaste: " << treasuresAll[idx].name << " (+" << treasuresAll[idx].value << " pts)";
                                lastMessage = ss.str(); messageTimer = 2.0f;
                                // si añadimos items, asegurarnos de que invScroll muestre el final si queremos:
                                if ((int)inventory.size() - invScroll > itemsPerPage) {
                                    // no cambiar scroll (dejar al jugador desplazarse); opción: autoscroll al final:
                                    // invScroll = max(0, (int)inventory.size() - itemsPerPage);
                                }
                            }
                            mapPosToTreasureIndex.erase(it);
                        }
                        grid[nr][nc] = ' ';
                    }
                }
            }
        }

        // comprobar fin
        bool timeUp = (timeLeft <= 0.0f);
        int remaining = 0; for (auto &pr : mapPosToTreasureIndex) { int rr = pr.first.first, cc = pr.first.second; if (grid[rr][cc] == 'T') remaining++; }
        bool allCollected = (remaining == 0);

        // dibujado
        BeginDrawing();
            ClearBackground(RAYWHITE);

            // mapa
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    int x = MARGIN + j * CELL;
                    int y = MARGIN + i * CELL;
                    Rectangle rc = { (float)x, (float)y, (float)CELL, (float)CELL };
                    DrawRectangleRec(rc, LIGHTGRAY);
                    if (!visible[i][j]) DrawRectangleRec(rc, GRAY);
                    else {
                        char ch = grid[i][j];
                        if (ch == '#') DrawRectangleRec(rc, DARKGRAY);
                        else if (ch == 'T') { DrawRectangleRec(rc, Fade(GOLD, 0.95f)); DrawText("T", x + CELL/4, y + CELL/6, CELL/2, BLACK); }
                        else if (ch == 'X') { DrawRectangleRec(rc, Fade(RED, 0.95f)); DrawText("X", x + CELL/4, y + CELL/6, CELL/2, BLACK); }
                        else DrawRectangleLines(x, y, CELL, CELL, Fade(LIGHTGRAY, 0.6f));
                    }
                    DrawRectangleLines(x, y, CELL, CELL, Fade(DARKGRAY, 0.6f));
                }
            }

            // jugador
            int px = MARGIN + player.c * CELL;
            int py = MARGIN + player.r * CELL;
            DrawRectangle(px + 4, py + 4, CELL - 8, CELL - 8, BLUE);
            DrawText("P", px + CELL/4, py + CELL/6, CELL/2, WHITE);

            // HUD (debajo del mapa)
            int hudY = MARGIN + N * CELL + 8;
            stringstream ss;
            ss << "Vidas: " << lives << "   Energia: " << energy << "   Puntuacion: " << score;
            DrawText(ss.str().c_str(), MARGIN, hudY, fontSize, BLACK);
            int minutes = (int)(timeLeft) / 60;
            int seconds = (int)(timeLeft) % 60;
            stringstream tss; tss << "Tiempo: " << minutes << ":" << (seconds < 10 ? "0" : "") << seconds;
            DrawText(tss.str().c_str(), MAP_W - 160, hudY, fontSize, DARKGREEN);
            stringstream ss2; ss2 << "Tesoros restantes: " << remaining << "   Pasos sin chocar: " << consec_no_hit;
            DrawText(ss2.str().c_str(), MARGIN, hudY + 22, fontSize, BLACK);
            DrawText("Controles: Flechas/WASD. Q salir. Scroll inventario: rueda/PgUp/PgDn", MARGIN, hudY + 44, 12, DARKBLUE);

            // Panel de la derecha: marco e título
            DrawRectangle(invPanelX - 8, invPanelY - 8, invPanelW + 16, invPanelH + 16, Fade(LIGHTGRAY, 0.08f));
            DrawRectangleLines(invPanelX - 8, invPanelY - 8, invPanelW + 16, invPanelH + 16, Fade(DARKGRAY, 0.25f));
            DrawText("Inventario", invPanelX + 8, invPanelY, 20, DARKGREEN);

            // área listable
            Rectangle invListArea = { (float)invPanelX + 8, (float)invPanelY + 28, (float)invPanelW - 24, (float)invPanelH - 48 };
            DrawRectangle(invListArea.x - 4, invListArea.y - 4, invListArea.width + 8, invListArea.height + 8, Fade(LIGHTGRAY, 0.02f));

            // recalcular itemsPerPage para este frame
            itemsPerPage = max(1, (int)(invListArea.height) / itemLineHeight);
            maxScroll = max(0, (int)inventory.size() - itemsPerPage);
            if (invScroll < 0) invScroll = 0;
            if (invScroll > maxScroll) invScroll = maxScroll;

            // dibujar items visibles
            for (int i=0;i<itemsPerPage;i++) {
                int idx = invScroll + i;
                int y = (int)(invListArea.y) + i * itemLineHeight;
                if (idx < (int)inventory.size()) {
                    stringstream itss; itss << (idx+1) << ". " << inventory[idx].name << " (+" << inventory[idx].value << " pts)";
                    DrawText(itss.str().c_str(), (int)invListArea.x + 4, y, 14, BLACK);
                }
            }

            // scrollbar en panel derecho si hace falta
            if ((int)inventory.size() > itemsPerPage) {
                int sbX = invPanelX + invPanelW - 16;
                int sbY = (int)invListArea.y;
                int sbW = 8;
                int sbH = (int)invListArea.height;
                DrawRectangle(sbX, sbY, sbW, sbH, Fade(DARKGRAY, 0.12f));
                float visibleRatio = (float)itemsPerPage / (float)inventory.size();
                int thumbH = max(12, (int)(sbH * visibleRatio));
                float scrollRatio = (float)invScroll / (float)maxScroll;
                int thumbY = sbY + (int)((sbH - thumbH) * scrollRatio);
                DrawRectangle(sbX, thumbY, sbW, thumbH, Fade(DARKBLUE, 0.9f));
            }

            // dibujar lastMessage dentro del panel (debajo de la lista)
            int msgY = invPanelY + invPanelH - 40;
            if (!lastMessage.empty()) DrawText(lastMessage.c_str(), invPanelX + 8, msgY, 14, MAROON);

            // FIN: overlay final cuando termine
            if (lives <= 0 || timeUp || allCollected) {
                int bonusTime = (int)round(timeLeft); if (bonusTime < 0) bonusTime = 0;
                int finalScore = score + bonusTime + (lives * 30) + (energy * 5);
                DrawRectangle(0,0,SCREEN_W,SCREEN_H, Fade(BLACK, 0.6f));
                if (allCollected) DrawText("Has recolectado todos los tesoros - Ganaste!", SCREEN_W/6, SCREEN_H/2 - 60, 20, RAYWHITE);
                else if (timeUp) DrawText("Se terminó el tiempo - Juego terminado", SCREEN_W/6, SCREEN_H/2 - 60, 20, RAYWHITE);
                else DrawText("Has perdido todas las vidas - Juego terminado", SCREEN_W/6, SCREEN_H/2 - 60, 20, RAYWHITE);

                stringstream fss; fss << "Puntuacion base: " << score;
                DrawText(fss.str().c_str(), SCREEN_W/6, SCREEN_H/2 - 20, 18, RAYWHITE);
                stringstream bonusss; bonusss << "Bonos: Tiempo(" << bonusTime << ") + Vidas(" << lives << "*30) + Energia(" << energy << "*5)";
                DrawText(bonusss.str().c_str(), SCREEN_W/6, SCREEN_H/2 + 4, 16, RAYWHITE);
                stringstream finalss; finalss << "Puntuacion final: " << finalScore;
                DrawText(finalss.str().c_str(), SCREEN_W/6, SCREEN_H/2 + 36, 20, YELLOW);
                DrawText("Presiona Q para salir.", SCREEN_W/6, SCREEN_H/2 + 70, 16, LIGHTGRAY);
            }

        EndDrawing();

        // si terminó y presionan Q, salir
        if ((lives <= 0 || timeUp || allCollected) && IsKeyPressed(KEY_Q)) break;
    }

    CloseWindow();
    return 0;
}
