#include "raylib.h"
#include <vector>
#include <string>
#include <map>
#include <random>
#include <chrono>
#include <sstream>

using namespace std;

const int N = 20;            // tamaño del mapa (N x N)
const int CELL = 28;         // tamaño de cada celda en píxeles
const int MARGIN = 8;        // margen alrededor del mapa
const int HUD_HEIGHT = 120;
const int SCREEN_W = N * CELL + MARGIN * 2;
const int SCREEN_H = N * CELL + MARGIN * 2 + HUD_HEIGHT;

const int INIT_LIVES = 3;
const int INIT_ENERGY = 4;
const int MAX_ENERGY = 10;

struct Pos { int r, c; };

int main() {
    // Inicializar ventana
    InitWindow(SCREEN_W, SCREEN_H, "Laberinto - Raylib (C++)");
    SetTargetFPS(60);

    // RNG con semilla
    std::mt19937 rng((unsigned)chrono::high_resolution_clock::now().time_since_epoch().count());
    auto rnd01 = [&](double p)->bool {
        uniform_real_distribution<double> d(0.0, 1.0); return d(rng) < p;
    };
    auto rndInt = [&](int a,int b)->int {
        uniform_int_distribution<int> d(a, b); return d(rng);
    };

    // GRID: ' ' vacio, '#' pared, 'T' tesoro, 'X' trampa
    vector<string> grid(N, string(N, ' '));
    vector<vector<bool>> visible(N, vector<bool>(N, false)); // niebla

    // Paredes aleatorias
    double wall_density = 0.20;
    for (int i=0;i<N;i++)
        for (int j=0;j<N;j++)
            if (rnd01(wall_density)) grid[i][j] = '#';

    // Bordes fijos
    for (int i=0;i<N;i++){ grid[i][0]='#'; grid[i][N-1]='#'; grid[0][i]='#'; grid[N-1][i]='#'; }

    // Posición inicial del jugador en celda libre
    Pos player{0,0};
    bool found=false;
    for (int attempts=0; attempts<10000 && !found; ++attempts) {
        int r=rndInt(0,N-1), c=rndInt(0,N-1);
        if (grid[r][c]==' ') { player.r=r; player.c=c; visible[r][c]=true; found=true; }
    }
    if (!found) {
        for (int i=0;i<N && !found;i++) for (int j=0;j<N && !found;j++)
            if (grid[i][j]==' ') { player.r=i; player.c=j; visible[i][j]=true; found=true; }
    }

    // Tesoros
    int num_treasures = 12;
    map<pair<int,int>,int> treasure_value;
    int placed_t = 0;
    for (int t=0; t<num_treasures && placed_t < N*N; ++t) {
        bool placed=false;
        for (int a=0;a<1000 && !placed;++a) {
            int r=rndInt(0,N-1), c=rndInt(0,N-1);
            if (grid[r][c]==' ' && !(r==player.r && c==player.c)) {
                grid[r][c] = 'T';
                treasure_value[{r,c}] = rndInt(5,50);
                placed=true; placed_t++;
            }
        }
        if (!placed) break;
    }

    // Trampas (max 6)
    int max_traps = 6;
    for (int t=0;t<max_traps;++t) {
        bool placed=false;
        for (int a=0;a<1000 && !placed;++a) {
            int r=rndInt(0,N-1), c=rndInt(0,N-1);
            if (grid[r][c]==' ' && !(r==player.r && c==player.c)) {
                grid[r][c] = 'X'; placed=true;
            }
        }
        if (!placed) break;
    }

    // Estado del jugador
    int lives = INIT_LIVES;
    int energy = INIT_ENERGY;
    int score = 0;
    int consec_no_hit = 0;

    // Fuente/tamaño
    int fontSize = 18;

    // Game loop
    while (!WindowShouldClose()) {
        // Entrada: una pulsación por frame
        int dr = 0, dc = 0;
        if (IsKeyPressed(KEY_UP) || IsKeyPressed(KEY_W)) { dr = -1; }
        else if (IsKeyPressed(KEY_DOWN) || IsKeyPressed(KEY_S)) { dr = 1; }
        else if (IsKeyPressed(KEY_LEFT) || IsKeyPressed(KEY_A)) { dc = -1; }
        else if (IsKeyPressed(KEY_RIGHT) || IsKeyPressed(KEY_D)) { dc = 1; }
        else if (IsKeyPressed(KEY_Q)) { break; }

        if ((dr != 0 || dc != 0) && lives > 0) {
            int nr = player.r + dr;
            int nc = player.c + dc;

            // fuera del mapa -> cuenta como pared (pierde energia)
            if (nr < 0 || nr >= N || nc < 0 || nc >= N) {
                if (energy > 0) energy--;
                consec_no_hit = 0;
            } else {
                char cell = grid[nr][nc];
                if (cell == '#') {
                    visible[nr][nc] = true;
                    if (energy > 0) energy--;
                    consec_no_hit = 0;
                } else {
                    // movimiento válido
                    player.r = nr; player.c = nc;
                    visible[nr][nc] = true;
                    consec_no_hit++;

                    // recuperar energía luego de 3 pasos sin chocar
                    if (consec_no_hit >= 3) {
                        if (energy < MAX_ENERGY) energy++;
                        consec_no_hit = 0;
                    }

                    if (cell == 'X') {
                        // trampa
                        lives--;
                        grid[nr][nc] = ' ';
                    } else if (cell == 'T') {
                        // tesoro
                        auto it = treasure_value.find({nr,nc});
                        int val = 0;
                        if (it != treasure_value.end()) { val = it->second; treasure_value.erase(it); }
                        score += val;
                        grid[nr][nc] = ' ';
                    }
                }
            }
        }

        // Dibujado
        BeginDrawing();
            ClearBackground(RAYWHITE);

            // Celdas
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    int x = MARGIN + j * CELL;
                    int y = MARGIN + i * CELL;
                    Rectangle rc = { (float)x, (float)y, (float)CELL, (float)CELL };

                    // suelo base
                    DrawRectangleRec(rc, LIGHTGRAY);

                    if (!visible[i][j]) {
                        // niebla
                        DrawRectangleRec(rc, GRAY);
                    } else {
                        char ch = grid[i][j];
                        if (ch == '#') {
                            DrawRectangleRec(rc, DARKGRAY);
                        } else if (ch == 'T') {
                            DrawRectangleRec(rc, Fade(GOLD, 0.95f));
                            DrawText("T", x + CELL/4, y + CELL/6, CELL/2, BLACK);
                        } else if (ch == 'X') {
                            DrawRectangleRec(rc, Fade(RED, 0.95f));
                            DrawText("X", x + CELL/4, y + CELL/6, CELL/2, BLACK);
                        } else {
                            // espacio vacío (ligera variación)
                            DrawRectangleLines(x, y, CELL, CELL, Fade(LIGHTGRAY, 0.6f));
                        }
                    }

                    // borde de celda
                    DrawRectangleLines(x, y, CELL, CELL, Fade(DARKGRAY, 0.6f));
                }
            }

            // Jugador (dibujado encima)
            int px = MARGIN + player.c * CELL;
            int py = MARGIN + player.r * CELL;
            DrawRectangle(px + 4, py + 4, CELL - 8, CELL - 8, BLUE);
            DrawText("P", px + CELL/4, py + CELL/6, CELL/2, WHITE);

            // HUD
            int hudY = MARGIN + N * CELL + 8;
            stringstream ss;
            ss << "Vidas: " << lives << "   Energia: " << energy << "   Puntuacion: " << score;
            DrawText(ss.str().c_str(), MARGIN, hudY, fontSize, BLACK);

            // contar tesoros restantes
            int remaining = 0;
            for (auto &pr : treasure_value) {
                int rr = pr.first.first, cc = pr.first.second;
                if (grid[rr][cc] == 'T') remaining++;
            }
            stringstream ss2;
            ss2 << "Tesoros restantes: " << remaining << "   Pasos sin chocar: " << consec_no_hit;
            DrawText(ss2.str().c_str(), MARGIN, hudY + 28, fontSize, BLACK);

            DrawText("Controles: Flechas o WASD (una pulsacion). Q para salir.", MARGIN, hudY + 56, 16, DARKBLUE);

            // Mensaje de fin
            if (lives <= 0) {
                DrawRectangle(0, 0, SCREEN_W, SCREEN_H, Fade(BLACK, 0.6f));
                DrawText("Has perdido todas las vidas - Juego terminado", SCREEN_W/6, SCREEN_H/2 - 20, 20, RAYWHITE);
            } else if (remaining == 0) {
                DrawRectangle(0, 0, SCREEN_W, SCREEN_H, Fade(BLACK, 0.6f));
                DrawText("Has recolectado todos los tesoros - Ganaste!", SCREEN_W/6, SCREEN_H/2 - 20, 20, RAYWHITE);
            }

        EndDrawing();
    }

    CloseWindow();
    return 0;
}
